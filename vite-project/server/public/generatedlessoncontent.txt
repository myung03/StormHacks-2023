## Introduction

Welcome to Lecture 23 of COMM 205: Introduction to Management Information Systems. Today we will be discussing Merging Datasets, Part II. In this lecture, we will cover two kinds of methods to merge datasets: `inner_join()` and `left_join()`. Joining allows us to match observations from two datasets based on matching values in a particular attribute(s). It is important to note that when merging two datasets, the variable names of the attribute(s) in both datasets should be the same to use the default syntax. It is also recommended that the variable type of the key variable(s) in both datasets also be the same.

<?!>## left_join() Function

The `left_join()` function returns all rows from dataset x, and all columns from both datasets x and y. Let's use the same example1 and example2 datasets from before. Suppose this time, you want to improve the example1 dataset by bringing as much information from the example2 as you can. Thus, you want to keep all the observations in the example1 dataset and bring new information for the matching observations in the example2 dataset. `left_join()` is suitable for this task.

To perform a `left_join()`, enter the following command into the console:

```R
merged2 <- left_join(example1,example2)
```

R will return `Joining, by = c("gvkey", "fyear")`. For matching values of the joining attribute – in this case, the combination of gvkey and fyear, `left_join()` links the information appearing in both datasets. Those observations in the “left” dataset which do not have matching observations in the other dataset will be retained in the resultant merged dataset, while those observations in the “right” dataset which do not have matching observations in the other dataset will not be retained in the resultant dataset. This explains why assets and sales are missing for AAR corporation in 2014 and 2015. The example2 dataset does not cover those years (it runs from fiscal year 2016 through 2018).

<?!>## Non-One-to-One Matching

When you merge two datasets whose key variable(s) uniquely identify each observation within the dataset, this kind of merge is called a one-to-one merge. However, the attribute(s) used as a basis of matching the observations in two datasets do not have to be key variables for both datasets. In such situations, an observation in one dataset can match with multiple observations in the other datasets through non-one-to-one matching. However, the variable or variable(s) to perform the merge should uniquely identify at least one of the datasets.

Suppose you have two datasets, the first is a subset of the full North American Stock Market 1994-2018.rds dataset. `example3.rds` contains gvkey, fyear, and industry code (naicsh) of all observations in fyear==2016. We can also create `example3` quite easily:

```R
example3 <- companies %>%
filter(fyear==2016, !is.na(naicsh)) %>%
select(gvkey, fyear, conm, naicsh)
```

This is a picture of `example3`.

![example3](https://i.imgur.com/9S2L1Y7.png)

`NAICS_2_6_digit_codes.rds` contains the NAICS code and industry description for more than 2,200 industries (from the 2 to the 6 digit level). You want to merge the two datasets so that each observation will have the following variables: gvkey, fyear, naicsh, and NAICS_description. This will attempt to add the industry description to every observation in the `example3` dataset.

To perform a non-one-to-one merge, enter the following command into the console:

```R
merged3 <- left_join(example3, NAICS_2_6_digit_codes, by = c("naicsh" = "NAICS"))
```

Here’s what you should see as a result:

![merged3](https://i.imgur.com/Z5gVv1Q.png)

<?!>## Conclusion

In conclusion, merging datasets is a crucial skill for data analysis. In this lecture, we covered the `left_join()` function and non-one-to-one matching. Remember to pay attention to the variable names and types when merging datasets. We hope you found this lecture informative and helpful for your future data analysis endeavors.
