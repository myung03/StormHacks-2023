## セクション1: データセットのマージ方法

このコースでは、データセットをマージするための2つの方法をカバーします。

1. **inner_join()**
2. **left_join()**

結合により、特定の属性の値が一致する2つのデータセットから観測値をマッチさせることができます。データセットをマージする場合、デフォルトの構文を使用するには、両方のデータセットの属性の変数名が同じである必要があります。また、両方のデータセットのキー変数の変数タイプも同じであることが推奨されます。

<?!>## セクション2: left_join()関数

**left_join(x, y)** は、xからすべての行と、xとyからすべての列を返します。前回のexample1とexample2データセットを使用して、今回はexample1データセットをexample2からできるだけ多くの情報を持ってくることで改善したいとします。つまり、example1データセットのすべての観測値を保持し、example2データセットの一致する観測値に新しい情報を持ってくることができます。**left_join()** はこのタスクに適しています。

<?!>## セクション3: left_join()関数の使用

これを行うには、コンソールに以下を入力します。

```
merged2 <- left_join(example1,example2)
```

Rは `Joining, by = c("gvkey", "fyear")` を返します。

<?!>## セクション4: left_join()関数の説明

結合属性の値が一致する場合、**left_join()** は両方のデータセットに表示される情報をリンクします。片方のデータセットに一致する観測値がない場合、左データセットの観測値は結果のマージデータセットに保持されますが、右データセットの観測値は結果のデータセットに保持されません。これが、2014年と2015年のAARコーポレーションに対して資産と売上が欠けている理由です。example2データセットはこれらの年をカバーしていません（2016年から2018年までの会計年度が対象です）。

<?!>## セクション5: 非1対1マッチング

2つのデータセットのキー変数がそれぞれのデータセット内で観測値を一意に識別する場合、このようなマージは1対1マージと呼ばれます。ただし、2つのデータセットの観測値をマッチさせるための基準となる属性（つまり、列）は、両方のデータセットに対してキー変数である必要はありません。このような状況では、1つのデータセットの観測値が、非1対1マッチングを介して他のデータセットの複数の観測値とマッチすることができます。

<?!>## セクション6: 非1対1マッチングの例

例えば、2つのデータセットがあります。最初のデータセットは、完全な北米株式市場1994-2018.rdsデータセットのサブセットです。example3.rdsは、fyear == 2016のすべての観測値のgvkey、fyear、および業界コード（naicsh）を含みます。また、以下のようにしてexample3を簡単に作成できます。

```
example3 <- companies %>%
filter(fyear==2016, !is.na(naicsh)) %>%
select(gvkey, fyear, conm, naicsh)
```

<?!>## セクション7: 非1対1マッチングの実行

NAICS_2_6_digit_codes.rdsには、2,200以上の業界（2桁から6桁レベルまで）のNAICSコードと業界の説明が含まれています。これはCanvasで提供されています。2つのデータセットをマージして、各観測値に次の変数が含まれるようにします。gvkey、fyear、naicsh、およびNAICS_description。これにより、Example3データセットのすべての観測値に業界の説明が追加されることになります。

これを行うには、コンソールに以下を入力します。

```
merged3 <- left_join(example3, NAICS_2_6_digit_codes, by = c("naicsh" = "NAICS"))
```

結果として表示されるものは次のようになります。
