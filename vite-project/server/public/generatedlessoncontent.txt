## COMM 205: 情報システム管理入門
## レクチャー23：データセットの結合、パートII

<?!>## データセットの結合
このコースでは、データセットを結合するための2つの方法をカバーします。

1. **inner_join()**
2. **left_join()**

結合により、特定の属性の値が一致する2つのデータセットから観測をマッチさせることができます。データセットを結合するとき、デフォルトの構文を使用するために、両方のデータセットの属性の変数名が同じである必要があります。また、両方のデータセットのキー変数の変数タイプも同じであることが推奨されます。

<?!>## left_join()関数
**left_join(x, y)**は、xからすべての行と、xおよびyからすべての列を返します。

前回と同じexample1とexample2のデータセットを使用しましょう。今回は、example1データセットを改善するために、example2からできるだけ多くの情報を取得したいとします。

そのため、example1データセットのすべての観測を保持し、example2データセットの一致する観測の新しい情報を持ってくる必要があります。このタスクには、**left_join()**が適しています。

<?!>## left_join()関数の使用方法
これを行うには、コンソールに次のように入力します。

```
merged2 <- left_join(example1,example2)
```

Rは、Joining, by = c("gvkey", "fyear")を返します。

<?!>## left_join()関数の機能
結合属性の値が一致する場合 - この場合、gvkeyとfyearの組み合わせ - **left_join()**は、両方のデータセットに表示される情報をリンクします。

"左"データセットの観測値が他のデータセットと一致しない観測値を持つ場合、その観測値は結果として得られる結合データセットに保持されますが、"右"データセットの観測値が他のデータセットと一致しない観測値を持つ場合、その観測値は結果として得られるデータセットに保持されません。

これが、AARコーポレーションの2014年と2015年の資産と売上が欠けている理由です。example2データセットは、それらの年をカバーしていません（2016年から2018年までの会計年度）。

<?!>## 非1対1マッチング
2つのデータセットのキー変数がそれぞれのデータセット内の観測値を一意に識別する場合、このようなマージは1対1マージと呼ばれます。

ただし、2つのデータセットの観測値をマッチさせるための基準となる属性（つまり、列）は、両方のデータセットのキー変数である必要はありません。

このような状況では、1つのデータセットの観測値が、他のデータセットの複数の観測値と非1対1マッチングを通じてマッチすることができます。

ただし、マージを実行するための変数または変数は、少なくとも1つのデータセットを一意に識別する必要があります。

<?!>## 非1対1マッチングの例
2つのデータセットがあり、1つ目は全米株式市場1994-2018.rdsデータセットのサブセットです。

**example3.rds**には、fyear==2016のすべての観測のgvkey、fyear、および業界コード（naicsh）が含まれています。

また、example3を簡単に作成することもできます。

```
example3 <- companies %>%
filter(fyear==2016, !is.na(naicsh)) %>%
select(gvkey, fyear, conm, naicsh)
```

これがexample3の概要です。

<?!>## 非1対1マッチングの実行
NAICS_2_6_digit_codes.rdsには、2,200以上の業界（2桁から6桁レベル）のNAICSコードと業界説明が含まれています。これはCanvasで提供されています。

各観測値に次の変数が含まれるように、2つのデータセットをマージしたいとします：gvkey, fyear, naicsh, およびNAICS_description。これにより、Example3データセットのすべての観測に業界説明が追加されることが期待されます。

これを行うには、コンソールに次のように入力します。

```
merged3 <- left_join(example3, NAICS_2_6_digit_codes, by = c("naicsh" = "NAICS"))
```

結果として次のように表示されます。
