## 第一部分：合并数据集简介

在这门课程中，我们将学习两种合并数据集的方法：

1. **inner_join()**
2. **left_join()**

**连接**允许我们根据特定属性中的匹配值将两个数据集中的观测值进行匹配。合并两个数据集时，应使用相同的属性名称以便使用默认语法。同时，建议要合并的数据集中的关键变量类型也相同。

<?!>## 第二部分：left_join()函数

**left_join(x, y)** 返回所有来自x的行和所有来自x和y的列。假设我们使用之前的example1和example2数据集。这次，你想通过从example2中获取尽可能多的信息来改进example1数据集。因此，你想保留example1数据集中的所有观测值，并为example2数据集中的匹配观测值带来新的信息。left_join()适用于这个任务。

要执行此操作，请在控制台中输入：

```
merged2 <- left_join(example1,example2)
```

对于连接属性中的匹配值 - 在这种情况下，gvkey和fyear的组合，**left_join()** 将链接两个数据集中出现的信息。在“左”数据集中没有匹配观测值的观测值将保留在合并后的数据集中，而在“右”数据集中没有匹配观测值的观测值将不会保留在合并后的数据集中。这就解释了为什么2014年和2015年的AAR公司缺少资产和销售。例2数据集不涵盖这些年份（它从财政年度2016年至2018年）。

<?!>## 第三部分：非一对一匹配

当你将两个数据集的关键变量唯一地确定每个数据集内的观测值时，这种合并称为一对一合并。然而，用作两个数据集观测值匹配基础的属性（即列）不必是两个数据集的关键变量。在这种情况下，一个数据集中的观测值可以通过非一对一匹配与另一个数据集中的多个观测值匹配。然而，执行合并的变量或变量至少应唯一地确定一个数据集。

假设你有两个数据集，第一个是完整的北美股票市场1994-2018.rds数据集的子集。example3.rds包含了fyear==2016的所有观测值的gvkey、fyear和行业代码（naicsh）。我们还可以很容易地创建example3：

```
example3 <- companies %>%
filter(fyear==2016, !is.na(naicsh)) %>%
select(gvkey, fyear, conm, naicsh)
```

<?!>## 第四部分：非一对一匹配示例

NAICS_2_6_digit_codes.rds 包含了超过2200个行业的NAICS代码和行业描述（从2位数到6位数级别）。这在Canvas上为您提供。你希望建立两个数据集，这样每个观测值将具有以下变量：gvkey、fyear、naicsh和NAICS_description。这将尝试为Example3数据集中的每个观测值添加行业描述。要执行此操作，请在控制台中输入：

```
merged3 <- left_join(example3, NAICS_2_6_digit_codes, by = c("naicsh" = "NAICS"))
```

完成后，你应该看到如下结果：
